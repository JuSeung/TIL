## JVM Runtime Data Area

### 1. JVM 의 구조
| OS                |
|-------------------|
| Other Application |
| JVM               |
| Unused            |

    - Java Virtual machine 이라고 한다.
    - 1. Java 파일은 컴파일 통해 Java Class 파일 생성 한다. 
    - 2. Java 명령어로 통해 해당 Class 파일을 실행 하면 JVM은
         Class Loader System 통해 클래스 파일을 읽어 들인다. 
    - 3. Class 파일 안에는 클래스 안에 어떤 필드(field)가 몇 개 선언돼 있는지, 메서드는 뭔지, 바이트 코드 포함 정보가 들어가 있다.
    - 4. 클래스 파일에 들어 있는 정보가 클래스 로더에 의해 Method Area에 올라간다.
    - 5. Runtime Data Area JVM이 사용하는 메모리 공간 이다.
    - 6. 바이트 코드는 jvm 알아듣는 명령어 집합 인다.기계화로 번역하는 일을 인터프리터가 수행하게 됩니다.
    - 7. Runtime Data Area는 5가지로 구성 되어져 있다.
#### Runtime Data Area 의 5가지 구성
    - 1. Method Area
        - 클래스 정보가 저장되는 영역
        - 스레드가 공유하는 영역
        - 멀티 스레드 프로그래밍 할때 동기화에 주의해야 하는 영역
    - 2. Heap
        - 런타임 생성되는 객체가 저장되는 영역
        - 가비지 컬렉터가 동작되는 곳
        - 스레드가 공유하는 영역
        - 멀티 스레드 프로그래밍 할때 동기화에 주의해야 하는 영역
    - 3. JVM Stacks
        - 메서드를 실행하기 위한 정보들이 저장되는 공간 
        - 프레임이라는 자료구조가 들어가있다.이 프레임은 메서드가 하나 호출될 때마다 새로 생기고 메서드가 끝나거나 예외가 터지면 사라진다.
        - 프레임 구조
            - localVariables Array가 있는데 지역변수를 담고있는 배열
            - 0 인덱스에는 this를 가지고 있고 매개변수가 있으면 다음 1로 지정 된다.
            - Operand Stack 피연산자 값을 넣는곳이다.
            - Constant pool이 있다 여긴 상수(이터럴)에 대한 정보를 가지고 있다.
    - 4. PC Registers
        - 현대 실행되고 있는 명령어의 주소를 저장하고 있는 영역
        - 멀티 스레드로 프로그래밍 환경에서 한 thread가 작업 하다가 다른 thread로 잠시 CPU 점유를 넘겨주고 다시 돌아왔을때
        - 이전에 어떤 명령어를 수행하고 있었는지 기억하고 있어야 이전 작업을 다시 이어 수행 할수 있기 때문에 이 영역에서 저장 하고 있다. 
    - 5. Native Method Stacks
        - C, C++ 실행되는 영역
    - JVM Stacks, PC Registers, Native Method Stacks 이 세 영역은 thread가 생성될 때마다 같이 생성 되고 서로 다른 thread가 침벌 할 수 없는 영역 이다.
    - JVM 가상기계 인데 왜 CPU 레지스터를 사용 하지 않고 스택을 사용 하는 이유는 다기종별로 레지스터가 동일하지 않고 모른다. 그렇기 때문에 연산을 할때 내부적으로 스택을 사용하여 다기종을 맞추기 위한것이다. 결국 하드웨어 스펙에 의존도지 않기 위한 것이다.


## GC 
- Garbage Collector
- Garbage Collection
> 불필요한 메모리를 수집하는 프로그램과 불필요한 메모리를 수집하는 동작 자체를 의미 할 수 있다. 

## 방법

### Mark And Sweep 알고리즘
- Mark And Sweep 알고리즘은 Heap에 생성된 객체 중, 프로그램에서 사용중인 객체만을 표시 (Mark) 한 후, 표시 되지 않은 객를 제거 합니다.

#### JVM GC 동작과정 

크게 두가지 영역으로 나눌 수 있습니다. Young generation 과 Old generation이 있습니다.
영 제너레이션에 일어나는 GC를 마이너 GC이고 올드 제너레이션에서 일어나는 메이저 GC 입니다.

영 제너레이션 영역을 세가지로 영역으로나누면 eden, suvivor0, suvivor1이 있습니다. 서바이버0과 서바이버1은 둘중 한곳은 무조건 비워져야 합니다.
에덴 영역이 가득차면 살아남은 영역을 서바이버0으로 옮기도 다음 에덴에 가득차게 되면 서바이버0에서 살아남은 객체나 에덴에서 살아남은 객체는 서바이버1에 옮겨집니다.
이렇게 gc가 발생할때마다 살아남은 객체는 ages가 증가를 하게 됩니다. 이렇게 진행하다가 age-bit 임계값에 도달하면 객체들은 old 제너레이션으로 옮겨 집니다. 
이과정을 프로모션이라고 합니다. old 제너레이션이 가득차면 메이저 GC가 발생 하는데 stop the word라고 잠시 application이 멈춥니다.
Java 8의 Parallel GC에서는 이 임계값이 15이다.

# Apache VS NginX
Apache	                                NginX
요청 당 스레드 또는 프로세스가 처리하는 구조	    비동기 이벤트 기반으로 요청
CPU/메모리 자원 낭비 심함	                CPU/메모리 자원 사용률 낮음
NginX보다 모듈이 다양	                    Apache에 비해 다양한 모듈이 없음
PHP 모듈 등 직접 적재 가능	                많은 접속자들 대응 가능
안정성, 확장성, 호환성 우세	                성능 우세
동적 컨텐츠 단독 처리 가능	                동적 컨텐츠 단독 처리 불가능